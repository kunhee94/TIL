# ALGORITHM

- 좋은 알고리즘이란?
  - 정확성 : 얼마나 정확하게 동작하는가
  - 작업량 : 얼마나 적은 연산으로 원하는 결과를 얻어내는가
  - 메모리 사용량 : 얼마나 적은 메모리를 사용하는가
  - 단순성 : 얼마나 단순한가
  - 최적성 : 더 이상 개선할 여지없이 최적화되었는가
- __시간 복잡도__
  - 실제 걸리는 시간을 측정
  - 실행되는 명령문의 개수를 계산
  - __빅-오 표기법__
    - 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
- __배열__
  - 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

---

### 정렬

- 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값 혹은 그 반대의 순서대로 재배열
- __버블 정렬__
  - 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
  - 시간 복잡도 O(n^2)

- __카운팅 정렬__
  - 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여,
    선형 시간에 정렬하는 효율적인 알고리즘
  - 시간복잡도 O(n+k).

- __완전 검색__
  - 모든 경우의 수를 나열해보고 확인하는 기법
  - 일반적으로 경우의 수가 상대적으로 작을 때 유용하다.
- __탐욕(greedy)알고리즘__
  - 최적해를 구하는 데 사용되는 근시안적인 방법
  - 여러 경우 중 하나를 결정해야 할 때마다 그순간에 최적이라고 생각되는 것을
    선택해 나가는 방식으로 진행하여 최종 해답 도달
  - 지역적으론 최적의 결정이지만, 그 결정들을 수집하여 최종 해답을 만들었다고 할 때,
    그것이 최적이라는 보장은 없다.

- __2차원 배열__
  - 세로길이, 가로길이의 선언을 필요로 함

```python
#지그재그순회
for i in range(n):
    for j in range(m):
        Array[i][j+ (m-1-2*j)*(i%2)]
```

```python
#델타를 이용한 2차 배열 탐색
#2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법

arr = [0...N-1][0...M-1] #NxM배열
di[] = [-1,1,0,0]
dj[] = [0,0,-1,-1]  #상하좌우
for i in range(N):
    for j in range(M):
        for k in range(4):
            ni = i + di[k]
            nj = j + dj[k]
            if 0 <= ni < N and  0 <= nj < M: 	#유효한 인덱스면
                test(arr[ni][nj])
```

- __부분집합__
  - 집합의 원소가 n개일 때, 공집합을 포함한 부분집합의 수는 2의n승 개이다.

```python
arr = [3,6,7,1,5,4]

n = len(arr)

for i in range(1<<n):	# 1<<n : 부분 집합의 개수
    for j in range(n):	# 원소의 수만큼 비트를 비교함
        if i & (1<<j):	# i의 j번 비트가 1인경우
            print(arr[j], end=", ")	#j번 원소 출력
print()
```

- __순차 검색__

  - 일렬로 되어있는 자료를 순서대로 검색하는 방법
    - 가장 간단하고 직관적인 건색방법
    - 배열이나 연결리스트 등 순차구조로 구현된 자료구조에서 원하는 한목을 찾을 때 유용함
    - 검색 대상의 수가 많은 경우 수행시간이 급격히 증가해 비효율적
  - 2가지 경우
    - 정렬되어 있지 않은 경우
      - 첫번째 키값부터 하나씩 비교하며 찾을때까지 찾음
      - 시간 복잡도: O(n)
    - 정렬되어 있는 경우
      - 오름차순의 자료를 검색한다고 가정
      - 순차적으로 자료를 검색하며 키값을 비교하고 원소의 키값이 검색대상의 키값보다 크면 찾는 원소가 없다는 것이므로 더이상 검색하지 않고 검색을 종료
      - 정렬 되어있으므로, 검색 실패를 반환하는 경우 평균 비교 횟수가 반으로 줄어든다.
      - 시간 복잡도: O(n)

- __이진 검색__

  - 자료의 가운데에 있는 항목의 키값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행

  - 목적 키를 찾을 떄까지 이진검색을 순환적으로 반복 수행함으로써 검색범위를 반으로 줄여가면서 보다 빠르게 검색을 수행함

  - 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 함

  - 검색 과정

    - 자료의 중앙에 있는 원소를 고른다
    - 중앙 원소의 값과 찾고자 하는 목표값을 비교한다
    - 목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해서 새로 검색을 수행하고, 크다면 자료의 오른쪽 반에 대해서 새로 검색을 수행한다.
    - 찾고자하는 값을 찾을 때까지 위의 과정 반복

    ```python
    def binarySearch(a, N, key):
        start = 0
        end = N-1
        while start <= end :
            middle = (start + end)//2
            if a[middle] == key : # 검색 성공
                return true
            elif a[middle] > key :
                end = middle -1 
            else :
                start = middle +1
            return false		# 검색 실패
    ```

- __선택 정렬__

  - 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식

  - 정렬과정

    - 주어진 리스트 중에서 최소값을 찾는다
    - 그 값을 리스트의 맨 앞에 위치한 값과 교환한다.
    - 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다.
    - 시간 복잡도: O(n**2)

    ```python
    # 선택 정렬
    def SelectionSort(arr,N):
        for i in range(N-1):
            minIDX = i
            for j in range(i+1, N):
                if arr[minIDX] > arr[j]:
                    minIDX = j
            arr[i], arr[minIDX] = arr[minIDX], arr[i]
            
    #아래는 k번째로 작은 원소를 찾는 알고리즘
    def select(arr, k):
        for i in range(k):
            minIDX = i
            for j in range(i+1, N):
                if arr[minIDX] > arr[j]:
                    minIDX = j
            arr[i], arr[minIDX] = arr[minIDX], arr[i]
        return arr[k-1]
    ```

    

















































































