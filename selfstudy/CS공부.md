### 자료구조

---

- Array는 어떤 자료구조인가요?

  - 메모리상에 연관된 데이터를 순차적이고 연속적으로 미리 할당하는 자료구조
  - resize를 해서 기존 size보다 더큰 array를 선언해서 데이터를 옮겨 할당하는 방법으로 크기를 넘어섯을때 해결합니다. 이런식으로 동적으로 배열의 크기를 조절하는 자료구조를 다이나믹 어레이라고 합니다.
  - 데이터 접근과 할당이 o(1)입니다.
  - resize시 o(n)입니다. 재할당시 필요이상의 메모리 공간을 할당하기에 사용되지 않고 낭비되는 메모리 공간이 발생합니다.

- Linked List?

  - 메모리상에 연관된 데이터를 물리적으로는 비연속적이지만 논리적으로 연속성을 갖게 저장하는 자료구입니다.

- 두개 비교

  - 조회를 많이하면 array 삽입,삭제가 잦다면 linked
  -  array는 컴파일 단계에서 stack메모리에 할당
  - linked는 runtime단계에서 새로운 노드가 추가될 떄마다 메모리에 할당 힙 메모리에 할당

  

- Queue

  - 선입선출의 자료구조 인큐 디큐 모두 o(1)
  - array로 구현하면 circle q로 구현합니다.

- Stack

  - 후입선출의 자료구조 팝 푸쉬 모두 o(1)

- Priority Queue

  - 들어간 순위에 상관없이 우선순위가 높은 데이터가 먼저나오는 자료구조
  - o(logn)

- BST(이진탐색트리)

  - 정렬된 tree임 왼쪽에는 더작은 노드 오른쪽에는 더 큰 노드

- Hash Table

  - 효율적인 탐색을 위한 자료구조로 키-밸류쌍으로 데이터를 입력





### OS

---

- process?
  - 프로그램을 메모리에 적재하고 cpu를 할당하여 실행되는것
  - 메모리영역은 스택, 힙, 데이터, 코드가 있음
- 멀티 프로세스?
  - 2개이상의 프로세스가 동시에 실행되는것 
  - 서로 다른 프로세스의 영역을 침범하지 않게 운영체제가 관리해줌
- 컨텍스트?
  - 시분할 시스템에서 이전에 어디까지 명령을 수행했고 레지스터에 어떤 값이 저장되어있었는지에 대한 정보. pcb에 저장
- PCB?
  - 운영체제가 프로세스를 표현한 자료구조
  - 프로세스 스테이트, 넘버, pc, 레지스터 등의 정보가 포함
- 스레드?
  - 프로세스 내에서 실행되는 동작의 단위
- 멀티스레드?
  - 하나의 프로세스가 동시에 여러개의 일을 수행할 수 있게 해주는것
  - 왜 멀티스레드는 스택메모리를 독자적으로 받는가?
    - 독립적인 기능을 실행한다는 것은 독립적으로 함수를 호출한다는 것이며 이에 함수 호출 시 인자. 함수의 지역변수 등을 저장하는 스택메모리역역이 독립적이여야함
  - process는 운영체제로부터 자원을 할당받는 작업의 단위이고 thread는 process가 할당받은 자원을 이용하는 실행의 단위

- 멀티 프로세스 환경에서 프로세스간에 데이터를 주고받는 법?
  - IPC는 크게 공유 메모리 모델과 메시지 전달 모델로 나눌 수 있습니다. 공유 메모리 모델은 주소 공간의 일부를 공유하며 공유한 메모리 영역에 read/write를 통해 통신하게 되는데, 예시로는 공유메모리와 POSIX가 있습니다. 메시지 전송 모델의 경우에는 kernel을 통해 send/receive 연산을 통해 데이터를 전송합니다. 예시로는 Pipe, socket, message queue 등이 있습니다.

- 동기화문제 해결법
  - Mutex란 1개의 스레드만이 공유 자원에 접근할 수 있도록 하여, 경쟁 상황(race condition)를 방지하는 기법입니다. 공유 자원을 점유하는 thread가 lock을 걸면, 다른 thread는 unlock 상태가 될 때까지 해당 자원에 접근할 수 없습니다.
  - Semaphore란 S개의 thread만이 공유 자원에 접근할 수 있도록 제어하는 동기화 기법입니다. Semaphore 기법에서는 정수형 변수 S(세마포) ****값을 가용한 자원의 수로 초기화하고, 자원에 접근할 때는 `S--` 연산을 수행하여 세마포 값을 감소시키고 자원을 방출할 때는 `S++` 연산을 수행하여 세마포 값을 증가시킵니다. 이 때 세마포 값이 0이 되면 모든 자원이 사용 중임을 의미하고, 이후 자원을 사용하려는 프로세스는 세마포 값이 0보다 커질 때까지 block 됩니다.

- Deadlock?

  - 둘 이상의 thread가 각기 다른 thread가 점유하고 있는 자원을 서로 기다릴 때, 무한 대기에 빠지는 상황을 말합니다.

    deadlock이 발생하는 조건은 상호 배제(mutual exclusion), 점유 대기(hold-and-wait), 비선점(no preemption), 순환 대기(circular wait)입니다. 이 4가지 조건이 동시에 성립할 때 발생할 수 있습니다.

    deadlock 문제를 해결하는 방법에는 무시, 예방, 회피, 탐지-회복의 4가지 방법이 있습니다



### Memory

---

- paging?
  - paging이란 process가 할당받은 메모리 공간을 일정한 page 단위로 나누어, 물리 메모리에서 연속되지 않는 서로 다른 위치에 저장하는 메모리 관리 기법입니다.

- Segmentation?
  - segmentation이란 process가 할당받은 메모리 공간을 논리적 의미 단위(segment)로 나누어, 연속되지 않는 물리 메모리 공간에 할당될 수 있도록 하는 메모리 관리 기법입니다.

- 가상메모리?
  - 가상 메모리(virtual memory)란 process 전체가 메모리에 올라오지 않더라도 실행이 가능하도록 하는 기법입니다. 가상 메모리 기법을 통해 사용자 프로그램이 물리적 메모리보다 커져도 실행이 가능하다는 장점이 있습니다.



### DB

---

- PK?

  - andidate key 중 선택한 main key로써, 각 row를 unique하게 구분하는 column(또는 column의 집합)을 말합니다. 그래서 기본키는 Null 값을 가질 수 없고, 중복된 값을 가질 수 없습니다. 기본키는 table당 1개만 지정해야합니다.

- RDB vs NoSQL

  - **관계형 데이터베이스(RDB)**는 사전에 엄격하게 정의된 DB schema를 요구하는 **table** 기반 데이터 구조를 갖습니다.

    **NoSQL(비관계형 데이터베이스)**은 table 형식이 아닌 **비정형 데이터**를 저장할 수 있도록 지원합니다.

    RDB는 엄격한 schema로 인해 데이터 중복이 없기 때문에 데이터 update가 많을 때 유리합니다.

    NoSQL의 경우 데이터 중복으로 인해 데이터 update 시 모든 컬렉션에서 수정이 필요하기 때문에 update가 적고 조회가 많을 때 유리합니다.

- Transaction
  - transaction는 데이터베이스 내에서 수행되는 작업의 최소 단위로, 데이터베이스의 무결성을 유지하며 DB의 상태를 변화시키는 기능을 수행합니다. transaction은 하나 이상의 query를 포함해야 하고, ACID라고 칭해지는 원자성, 일관성, 고립성, 지속성의 4가지 규칙을 만족해야합니다. 

- Index?

  - Index는 데이터베이스에서 table의 검색 성능을 높여주는 대표적인 방법중 하나입니다. 일반적인 RDBMS(관계형데이터베이스)에서는 B+Tree구조로 된 index를 사용하여 검색속도를 향상시킵니다.

    index는 책마다 마지막 페이지에 있는 색인(index)과 같은 역할을 하는 자료구조입니다. 책에서 어떤 용어나 단어를 찾기위해 첫 페이지부터 끝 페이지 까지 전체를 훑지 않아도(Full Table Scan) index를 찾아보면 몇 페이지에 적혀 있는지 바로 찾을 수 있는 것(Index Scan)과 비슷합니다.

    SELECT ~WHERE query를 통해 특정 조건을 만족하는 데이터를 찾을 때, full table scan할 필요 없이 정렬되어 있는 index에서 훨씬 빠른 속도로 검색을 할 수 있게 됩니다.

  - index는 where 절에서 자주 조회되고, 수정 빈도가 낮으며, 카디널리티는 높고, 선택도가 낮은 column을 선택해서 설정하는 것이 가장 좋습니다.



### 네트워크

---

- OSI vs TCP/IP

  - OSI 7계층은 **네트워크 통신을 표준화한 모델**로, 통신 시스템을 7단계로 나누어 설명한 것입니다.

    하지만 OSI 모델이 실무적으로 이용하기에 복잡한 탓에 실제 인터넷에서는 이를 단순화한 TCP/IP 4계층이 사용되고 있습니다.

  - 응표세전네데물, 응전인네

- TCP vs UDP

  - TCP는 연결형, 신뢰성 전송 프로토콜 입니다.  연결지향적 서비스를 제공하기 위해 데이터를 전송하기 전에 3way handsaking을 하여 두 호스트의 전송 계층 사이에 논리적 연결을 설립합니다. 신뢰성 있는 서비스를 제공하기 위해 오류제어, 흐름제어, 혼잡제어 등을 실행합니다. 신뢰성을 보장하기 위해서 header가 더 크고 속도가 비교적 느리다는 단점이 있습니다.

    UDP는 비연결형 프로토콜로 3-way handshake 등의 세션 수립 과정이 없습니다. 또한 비신뢰성 프로토콜로 흐름제어, 오류제어, 혼잡 제어를 제공하지 않습니다. 이러한 단순성 덕분에 적은 양의 오버헤드갖고 수신여부를 확인하지 않아서 속도가 빠릅니다

- 3way handshake

  - 3-way handshake는 TCP/IP 프로토콜로 통신하기 전, 정확한 정보 전송을 위해 상대방 컴퓨터와 세션을 수립하는(연결을 하는) 과정입니다. **(TCP 연결 초기화)**

    클라이언트가 서버에게 접속을 요청하는 **SYN** 패킷을 보내면, 서버는 요청을 수락하는 ACK를 포함하여 **SYN+ACK** 패킷을 클라이언트에게 발송합니다. 클라이언트가 이것을 수신한 후, 다시 **ACK**를 서버에게 발송하면 연결이 이루어지고, 이로써 데이터를 주고받을 수 있게됩니다.

- HTTP
  - HTTP는 HyperText Transfer Protocol의 약자로 서버-클라이언트 모델을 따르면서 request/response 구조로 웹 상에서 정보를 주고받을 수 있는 프로토콜입니다. TCP/IP 기반으로 작동하며,  HTTP의 가장 큰 특징은 Connectionless와 Stateless 입니다
- 쿠키 vs 세션
  - 세션은 서버의 자원을 사용하기 때문에 서버가 느려질 수 있고 서버 자원이 부족할 수 있습니다. 따라서 쿠키를 사용하면 서버 자원의 낭비를 방지하여 웹사이트 속도를 높일 수 있습니다.























