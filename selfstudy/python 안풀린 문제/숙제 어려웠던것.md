# 숙제 어려웠던것

### 중간값찾기

```python
numbers = [85,72,38,80,69,65,68,96,22,49,67,
           51,61,63,87,66,24,80,83,71,60,64,
           52,90,60,49,31,23,99,94,11,25,24]
a=sorted(numbers) #이걸로 정렬
n=0
for i in numbers:
    n+=1
print(a[round(n/2)]) #round 함수는 반올림 함수
```

### 약수 구하기

```python
a=int(input())

for i in range(1,a+1):
    if a%i==0:
        print(i,end=' ') #다른건 다 알겠는데 end=" "이걸 모름 다시 외워보자
```

### 이중 List

```python
# all_list_sum([[1], [2,3], [4,5,6], [7,8,9,10]])=55를 반환하는 함수를 만들어라


def all_list_sum(a):
    k=[]
    total=0
    for i in a:
        k+=i      #이것 때문에 k값이 계속 증가하니까
    	for j in k:
        	total+=j
        k=[]       #여기서 k값을 초기화 해주어야함
    return total
            
all_list_sum([[1], [2,3], [4,5,6], [7,8,9,10]])

def all_list_sum(a):
    k=[]
    total=0
    for i in a:
        k+=i
    for j in k:
        total+=j         #이런식으로 아예 2중for문이 아니라 걍 밖으로 끄집어 내버리면 문제는 해결되                            긴함
    return total 
            
all_list_sum([[1], [2,3], [4,5,6], [7,8,9,10]])
```

### 복소수

```python
#abs함수 만들기 중에 복소수 처리가 너무 어려웠음
#x.real==복소수의 실수부 x.imag ==복소수의 허수부
# 복소수 a+bj 의 절대값==(a**2+b**2)**0.5
def my_abs(x):
    if type(x)==complex:
        return (x.real**2+x.imag**2)**0.5
    if type(x)!=complex and x>0:
        return x
    elif type(x)!=complex and x<=0:
        return -x
        
```

### ord 함수 이용

```python
 #ord()글자의 아스키코드 부르기
#chr()숫자의 아스키 문자 부르기
def get_strong_word(w1,w2):      #argument가 문자열인데 ord()는 스트링 1개씩 받는 문제 발생 
    number1=list(map(ord,w1))    #각 문자열을 하나하나 리스트에 담고 따로 실행하니까 해결
    number2=list(map(ord,w2))    
    N1=0
    N2=0
    for i in number1:
        N1+=i
    for j in number2:
        N2+=j
    if N1>N2:
        return w1
    else:
        return w2
        
    
get_strong_word('tom','john')   
```

### all함수 만들기

```python
def my_all(k):
    a_list=[]              # 4.a를 받을 빈 리스트가 필요해...
    if k==[]:              # 1.아무것도 없는 경우부터 만들자
        return True
    for i in k:            # 2.k를 for구문으로 돌려서 각각 참,거짓을 구별해보자
        if i:
            a= True        # 3.k가 여러개니까 a로 받고 리스트로 만들어서 리스트를 또 for구문 돌리면 되지않을까?       
        else:
            a= False
        a_list+=[a]
        for j in a_list:        #5.리스트 원소들을 이제 하나씩 비교해서 리턴하면 끝!
            if j==False:
                return False
            else:
                return True
```

### any함수 만들기

```python
def my_any(k):         #나는 똥멍청이였다.
    for i in k:		   # 어차피 k에 리스트로 들어오니까 걍 k의 원소들 참거짓만 판별하면 되는거 였음				
        if i:
            return True
    return False       #심지어 if문 안에서 True안뜨면 False밖에 없으니까 else따위 안쓰고 걍 False 리턴 해버리면 됨
```

### Str 숫자로 바꾸기

```pyt
def is_id_valid(user_data):
    a=user_data.get('id')
    b=a[-1]
    #1번 방법 .isdigit()을 쓴다.
    #문자열이 숫자로만 이루어져 있는지 확인하는 함수임
    # if b.isdigit()==True:
    #     return True
    # else:
    #     return False
    ##2번방법 ord로 유니코드로 변환해서 비교한다.
    if ord('1')<=ord(b)<=ord('9'):
        return True
    else:
        return False
```

### 회문 판별하기

```python
#for문 사용하니까 너무 쉬운데 while문 조건작성이 너무 어려웟다.
#for문 활용1
def is_pal_while(word):
    cnt=0
    a=''
    for i in word:
        cnt=cnt-1
        a+=word[cnt]
    if a==word:
        return '회문입니다'
    else:
        return '회문이 아닙니다'
#for문 활용2
def is_pal_recursive(word):
    cnt=0
    for i in word:
        cnt+=1
        if word[cnt-1]==word[-cnt]:
            return '회문입니다.'
        else:
            return '회문이 아닙니다.'

#while문 활용
def is_pal_while(word):
    cnt=0
#while문 조건을 위한 cnt와 cnt2 그리고 단어를 뒤집기위해 cnt3를 추가
    cnt2=0
    cnt3=0
    a=''
    for i in word:
        cnt+=1
    while cnt2<cnt:
        cnt2+=1
        cnt3=cnt3-1
        a+=word[cnt3]
    if a==word:
        return '회문입니다.'
    else:
        return '회문이 아닙니다.'

```

### 중복되는 문자 찾기

```python
def duplicated_letters(word):
    #str을 리스트에 담아서 .count()를 쓸준비를한다
    a=list(word)
    b=[]
    #정답을 담을 리스트 준비
    cnt=0
    for i in a:
        if a.count(i)>1:
            # .count()를 사용해 중복되는 문자들을 뽑는다.
            if b.count(i)==0:
            #b에 중복된 문자들을 담는다(대신 이미 넣었으면 넣으면 안되므로 위의 조건문을 작성)
                b+=[i]
    return b
```

### 소문자대문자번갈아가며 나오게하기

```python
def low_and_up(word):
    a=''
    #바꾼 문자열을 담을 a준비
    for i in range(len(word)):
        #문자열 길이만큼 돌아야함
        if i%2==0:
        #짝수인덱스 일때는 소문자그대로 놔두기
            a+=word[i]
        else:
        #홀수인덱스는 대문자로 바꾸기
            a+=word[i].upper()
         #이런식으로 따로 담는 이유는 문자열이 immutable한 객체라서 안바뀌기 때문에 반환한 
		 #문자열을 받아적을 빈문자열이 필요함
    return a
```

### 연속되는 숫자는 1개만 남기고 지우기

```python
def lonely(numbers):
    number=[]
    #정답을 담을 빈리스트 작성
    for i in range(0,len(numbers)):
        #리스트 길이만큼 돌아야됨
        if numbers[i]!=numbers[i-1]:
        #바로 전 문자열과 비교했을 때 변했으면 담으면됨
            number.append(numbers[i])
        elif i==0:
        #맨앞 문자는 비교할 대상이 없으니까 그냥 담아 줌
            number.append(numbers[i])
    return number
```

### while문 활용해서 2차원 자료 더하기

```python
def sum_list_while(numbers):
    a=[]
    total=0
    cnt1=0
    #첫번째 while문 종료조건을 위해 설정
    cnt=0
    #두번째 while문 종료조건을 위해 설정
    while cnt1<len(numbers):
    #2차원 자료를 한차례 벗겨서 1차원으로 만듬
        a+=numbers[cnt1]
        cnt1+=1   
    while cnt<len(a):
    #1차원으로 만든 리스트의 요소를 전부 더함
        total+=a[cnt]
        cnt+=1
    return total
print(sum_list_while([[1, 4], [10, 5], [20, 30]]))
```

### 2차원 자료 2중for문 +인덱스로 접근해서 뽑아내기

```python
students = [
 [100, 80, 100],           #세로로 더해서 하나씩 출력해야함
 [90, 90, 60],
 [80, 80, 80]
]
'''
students[0][0]+students[1][0]+stunts[2][0]
students[0][1]+students[1][1]+stunts[2][1]
students[0][2]+students[1][2]+stunts[2][2]
를 구해야함
'''
total=0
for i in range(len(students)):
    #일단 주어진 자료형 개수만큼 돌아야됨
    for j in range(len(students)):
        #이렇게하면 i 한번돌 때 각 j는 전부 돈다
        total+=students[j][i]
    print(total)
    total=0
    #누적으로 더하는것을 막기위해 초기화 시켜주기

```

### 클래스 구현하기

```python
class Point:		
    
    def __init__(self,x,y):
        self.x=int(x)
        self.y=int(y)
        


class Rectangle():
    def __init__(self,p1,p2):									#2.여기서 생성자에 인자로 Point클래스의 인스턴스를 전달
        self.p1=p1												#상속받는게 아니고 걍 다른클래스 객체를 가져다 쓰는거임
        self.p2=p2
    
    def get_area(self):
        return abs(self.p2.x-self.p1.x)*abs(self.p2.y-self.p1.y)

    def get_perimeter(self):
        return (abs(self.p2.x-self.p1.x)+abs(self.p2.y-self.p1.y))*2

    def is_square(self):
        if abs(self.p2.x-self.p1.x)==abs(self.p2.y-self.p1.y):
            return True
        else:
            return False

p1=Point(1,3)														#1.p1이라는 Point클래스의 인스턴스를 생성
p2=Point(3,1)
r1=Rectangle(p1,p2)
print(r1.get_area())
print(r1.get_perimeter())
print(r1.is_square())
p3=Point(3,7)
p4=Point(6,4)
r2=Rectangle(p3,p4)
print(r2.get_area())
print(r2.get_perimeter())
print(r2.is_square())

```

### 랜덤으로 짝지어주기

```python
class ClassHelper:
    pass
    # 아래에 코드를 작성하시오.
    name=[]
                                                            #클래스 변수에 리스트 저장
    def __init__(self,name):                                #생성자 메서드로 클래스 변수에 넣어줌
        self.name=name
        ClassHelper.name=self.name
            
    @staticmethod        
    def pick(n=0):                                         #스태틱메서드로 pick()함수 만들기 빈리스트를 대비해서 디폴트값 설정
        import random
        result=random.sample(ClassHelper.name, n)
        return result
    
    def match_pair(self):
        import random
        k=list(ClassHelper.name)                           #옅은 복사로 똑같은 요소가진 리스트 생성(반복할때마다 지울거니까)
        li=[]                                              #결과 받을 리스트 
        if len(k)%2==1:                                    #홀수일때
            for _ in range(len(k)//2-1):                   #2로 나눈몫의 -1까지는 2개씩 묶어내야함
                a=random.sample(k, 2)                      
                for j in a:
                    if j not in li:                        #묶어낸게 만약 li에 있으면 삭제해야 겹치는 사태 발생 x
                        k.remove(j)
                li.append(a)                               #겹치는 경우 빼고 li에 추가
        if len(k)%2==0:                                    #짝수일때
             for _ in range(len(k)//2):                    #걍 2로 나눈 몫만큼 길이 2짜리 리스트 생성하면됨
                b=random.sample(k, 2)                     
                for i in b:
                    if i not in li:                        #마찬가지 겹치는 사태 방지를 위한 remove
                        k.remove(i)
                li.append(b)
        li.append(k)                                       #홀수때 2짝씩 찍어내고 남은 3개 그냥 li에 추가해주면됨
        return li
```

